// IPC (Inter-Process Communication) Module
// Handles communication between the UI thread and JS runtime thread

use std::sync::mpsc::{self, Receiver, Sender};

// ============================================================================
// UI Events: Sent from UI Thread -> JS Thread
// ============================================================================

/// Events generated by the UI thread and sent to the JS runtime
#[derive(Debug, Clone)]
pub enum UiEvent {
    /// Window was resized
    WindowResized { width: u32, height: u32 },

    /// Mouse click occurred
    MouseClick { x: f64, y: f64 },

    /// Mouse moved
    MouseMove { x: f64, y: f64 },

    /// Key was pressed
    KeyPress {
        key: String,
        modifiers: KeyModifiers,
    },

    /// Key was released
    KeyRelease {
        key: String,
        modifiers: KeyModifiers,
    },

    /// Text input received
    TextInput { text: String },

    /// Widget action triggered (button click, etc.)
    WidgetAction {
        widget_id: String,
        action: WidgetActionKind,
    },

    /// Window focus changed
    WindowFocusChanged { focused: bool },

    /// Window close requested
    WindowCloseRequested,

    /// Application is about to exit
    AppExit,
}

/// Keyboard modifier state
#[derive(Debug, Clone, Default)]
pub struct KeyModifiers {
    pub shift: bool,
    pub ctrl: bool,
    pub alt: bool,
    pub meta: bool,
}

/// Kind of widget action
#[derive(Debug, Clone)]
pub enum WidgetActionKind {
    Click,
    DoubleClick,
    TextChanged(String),
    ValueChanged(f64),
    Custom(String),
}

// ============================================================================
// JS Commands: Sent from JS Thread -> UI Thread
// ============================================================================

/// Commands generated by the JS runtime and sent to the UI thread
#[derive(Debug, Clone)]
pub enum JsCommand {
    /// Set the window title
    SetTitle(String),

    /// Create a new widget
    CreateWidget {
        id: String,
        kind: WidgetKind,
        parent_id: Option<String>,
    },

    /// Update an existing widget
    UpdateWidget {
        id: String,
        updates: Vec<WidgetUpdate>,
    },

    /// Remove a widget
    RemoveWidget { id: String },

    /// Set widget text content
    SetWidgetText { id: String, text: String },

    /// Set widget visibility
    SetWidgetVisible { id: String, visible: bool },

    /// Request window resize
    ResizeWindow { width: u32, height: u32 },

    /// Request window close
    CloseWindow,

    /// Log a message (for debugging)
    Log { level: LogLevel, message: String },

    /// Request to exit the application
    ExitApp,
}

/// Widget types that can be created
#[derive(Debug, Clone)]
pub enum WidgetKind {
    Label,
    Button,
    TextInput,
    TextArea,
    Container,
    Flex,
    Custom(String),
}

/// Possible widget updates
#[derive(Debug, Clone)]
pub enum WidgetUpdate {
    Text(String),
    Enabled(bool),
    Visible(bool),
    Style(String, String),
}

/// Log levels for debugging
#[derive(Debug, Clone)]
pub enum LogLevel {
    Debug,
    Info,
    Warn,
    Error,
}

// ============================================================================
// Channel Types and Factory
// ============================================================================

/// Sender for UI events (UI thread holds this)
pub type UiEventSender = Sender<UiEvent>;

/// Receiver for UI events (JS thread holds this)
pub type UiEventReceiver = Receiver<UiEvent>;

/// Sender for JS commands (JS thread holds this)
pub type JsCommandSender = Sender<JsCommand>;

/// Receiver for JS commands (UI thread holds this)
pub type JsCommandReceiver = Receiver<JsCommand>;

/// Contains all channel endpoints needed for IPC
pub struct IpcChannels {
    /// Endpoints for the UI thread
    pub ui_thread: UiThreadChannels,
    /// Endpoints for the JS thread
    pub js_thread: JsThreadChannels,
}

/// Channel endpoints held by the UI thread
pub struct UiThreadChannels {
    /// Send UI events to JS thread
    pub event_sender: UiEventSender,
    /// Receive commands from JS thread
    pub command_receiver: JsCommandReceiver,
}

/// Channel endpoints held by the JS thread
pub struct JsThreadChannels {
    /// Receive UI events from UI thread
    pub event_receiver: UiEventReceiver,
    /// Send commands to UI thread
    pub command_sender: JsCommandSender,
}

impl IpcChannels {
    /// Create a new pair of IPC channels for communication between threads
    pub fn new() -> Self {
        // Create channel for UI events (UI -> JS)
        let (ui_event_tx, ui_event_rx) = mpsc::channel::<UiEvent>();

        // Create channel for JS commands (JS -> UI)
        let (js_command_tx, js_command_rx) = mpsc::channel::<JsCommand>();

        IpcChannels {
            ui_thread: UiThreadChannels {
                event_sender: ui_event_tx,
                command_receiver: js_command_rx,
            },
            js_thread: JsThreadChannels {
                event_receiver: ui_event_rx,
                command_sender: js_command_tx,
            },
        }
    }
}

impl Default for IpcChannels {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_channel_communication() {
        let channels = IpcChannels::new();

        // Simulate UI thread sending event
        channels
            .ui_thread
            .event_sender
            .send(UiEvent::MouseClick { x: 100.0, y: 200.0 })
            .expect("Failed to send UI event");

        // Simulate JS thread receiving event
        let event = channels
            .js_thread
            .event_receiver
            .recv()
            .expect("Failed to receive UI event");

        match event {
            UiEvent::MouseClick { x, y } => {
                assert_eq!(x, 100.0);
                assert_eq!(y, 200.0);
            }
            _ => panic!("Unexpected event type"),
        }

        // Simulate JS thread sending command
        channels
            .js_thread
            .command_sender
            .send(JsCommand::SetTitle("Test Title".to_string()))
            .expect("Failed to send JS command");

        // Simulate UI thread receiving command
        let command = channels
            .ui_thread
            .command_receiver
            .recv()
            .expect("Failed to receive JS command");

        match command {
            JsCommand::SetTitle(title) => {
                assert_eq!(title, "Test Title");
            }
            _ => panic!("Unexpected command type"),
        }
    }
}
