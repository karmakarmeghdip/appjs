use std::fmt;

/// Commands generated by the JS runtime and sent to the UI thread
#[derive(Debug, Clone)]
pub enum JsCommand {
    /// Set the window title
    SetTitle(String),

    /// Create a new widget
    CreateWidget {
        id: String,
        kind: WidgetKind,
        parent_id: Option<String>,
    },

    /// Update an existing widget
    UpdateWidget {
        id: String,
        updates: Vec<WidgetUpdate>,
    },

    /// Remove a widget
    RemoveWidget { id: String },

    /// Set widget text content
    SetWidgetText { id: String, text: String },

    /// Set widget visibility
    SetWidgetVisible { id: String, visible: bool },

    /// Request window resize
    ResizeWindow { width: u32, height: u32 },

    /// Request window close
    CloseWindow,

    /// Log a message (for debugging)
    Log { level: LogLevel, message: String },

    /// Request to exit the application
    ExitApp,
}

/// Widget types that can be created
#[derive(Debug, Clone)]
pub enum WidgetKind {
    Label,
    Button,
    TextInput,
    TextArea,
    Container,
    Flex,
    Custom(String),
}

/// Possible widget updates
#[derive(Debug, Clone)]
pub enum WidgetUpdate {
    Text(String),
    Enabled(bool),
    Visible(bool),
    Style(String, String),
}

/// Log levels for debugging
#[derive(Debug, Clone)]
pub enum LogLevel {
    Debug,
    Info,
    Warn,
    Error,
}

/// Wrapper around JsCommand that can be sent as an ErasedAction through the EventLoopProxy.
/// ErasedAction = Box<dyn AnyDebug + Send>, where AnyDebug is auto-implemented for Any + Debug.
/// So this type just needs Debug + Send + 'static (JsCommand is Clone+Debug, all String fields).
pub struct JsCommandAction(pub JsCommand);

impl fmt::Debug for JsCommandAction {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "JsCommandAction({:?})", self.0)
    }
}
